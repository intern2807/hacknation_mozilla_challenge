#!/bin/bash
# Harbor Installer - Post-install setup
# This script runs after files are copied to set up native messaging and Firefox extension

set -e

LOG_FILE="/tmp/harbor-install.log"
echo "Harbor post-install started at $(date)" >> "$LOG_FILE"

# Installation paths
HARBOR_DIR="/Library/Application Support/Harbor"
HARBOR_BIN="$HARBOR_DIR/harbor-bridge"
HARBOR_XPI="$HARBOR_DIR/harbor.xpi"

# =============================================================================
# Select correct binary for current architecture
# =============================================================================
select_binary() {
    echo "Selecting binary for current architecture..."
    
    # Use sysctl to detect native architecture (works even under Rosetta)
    # uname -m can return x86_64 when running under Rosetta on Apple Silicon
    if sysctl -n hw.optional.arm64 2>/dev/null | grep -q "1"; then
        ARCH="arm64"
    else
        ARCH=$(uname -m)
    fi
    echo "  Detected architecture: $ARCH" >> "$LOG_FILE"
    
    if [ "$ARCH" = "arm64" ]; then
        BINARY_SOURCE="$HARBOR_DIR/harbor-bridge-arm64"
    else
        BINARY_SOURCE="$HARBOR_DIR/harbor-bridge-x64"
    fi
    
    if [ -f "$BINARY_SOURCE" ]; then
        # Copy the correct binary
        cp "$BINARY_SOURCE" "$HARBOR_BIN"
        chmod +x "$HARBOR_BIN"
        echo "  ✓ Selected $ARCH binary"
        echo "  Selected binary: $BINARY_SOURCE -> $HARBOR_BIN" >> "$LOG_FILE"
        
        # Clean up both architecture-specific binaries
        rm -f "$HARBOR_DIR/harbor-bridge-arm64" 2>/dev/null || true
        rm -f "$HARBOR_DIR/harbor-bridge-x64" 2>/dev/null || true
    elif [ -f "$HARBOR_BIN" ]; then
        # Single-arch build already has the binary in place
        echo "  ✓ Using pre-built binary"
        echo "  Using pre-built binary at: $HARBOR_BIN" >> "$LOG_FILE"
    else
        echo "  ✗ ERROR: No suitable binary found for $ARCH!" | tee -a "$LOG_FILE"
        exit 1
    fi
}

# Firefox native messaging paths
FIREFOX_NATIVE_HOSTS="/Library/Application Support/Mozilla/NativeMessagingHosts"
MANIFEST_NAME="harbor_bridge_host"

# Firefox extension ID (must match extension's manifest.json)
# This is stamped by build-pkg.sh from credentials.env
EXTENSION_ID="__EXTENSION_ID__"

# =============================================================================
# Create launcher script
# =============================================================================
create_launcher() {
    echo "Creating launcher script..."
    
    LAUNCHER_SCRIPT="$HARBOR_DIR/harbor-bridge-launcher"
    
    cat > "$LAUNCHER_SCRIPT" << 'LAUNCHER_EOF'
#!/bin/bash
# Harbor Bridge Launcher
# Wrapper script for native messaging

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Suppress Node.js warnings that could corrupt the native messaging protocol
export NODE_NO_WARNINGS=1

# Tell pkg where to find native modules (better-sqlite3)
# The native .node files are in the native/ subdirectory
export PKG_EXECPATH="$SCRIPT_DIR/harbor-bridge"

# Log file for debugging
LOG_FILE="$HOME/.harbor/bridge.log"
mkdir -p "$(dirname "$LOG_FILE")"

# Execute the bridge, redirecting stderr to log file
exec "$SCRIPT_DIR/harbor-bridge" 2>>"$LOG_FILE"
LAUNCHER_EOF

    chmod +x "$LAUNCHER_SCRIPT"
    echo "Launcher script created at: $LAUNCHER_SCRIPT" >> "$LOG_FILE"
}

# =============================================================================
# Install native messaging manifest
# =============================================================================
install_native_manifest() {
    echo "Installing native messaging manifest..."
    
    # Create directory if it doesn't exist
    mkdir -p "$FIREFOX_NATIVE_HOSTS"
    
    # Get the launcher path
    LAUNCHER_PATH="$HARBOR_DIR/harbor-bridge-launcher"
    
    # Create the system-wide manifest
    MANIFEST_FILE="$FIREFOX_NATIVE_HOSTS/${MANIFEST_NAME}.json"
    
    cat > "$MANIFEST_FILE" << EOF
{
  "name": "$MANIFEST_NAME",
  "description": "Harbor Bridge - AI Agent Platform with MCP Tools",
  "path": "$LAUNCHER_PATH",
  "type": "stdio",
  "allowed_extensions": ["$EXTENSION_ID"]
}
EOF

    echo "Native messaging manifest installed at: $MANIFEST_FILE" >> "$LOG_FILE"
    echo "  ✓ System manifest installed: $MANIFEST_FILE"
    
    # Also update/remove user-level manifest if it exists (it takes precedence)
    # Try to find the actual user (the one who ran sudo)
    ACTUAL_USER="${SUDO_USER:-}"
    if [ -z "$ACTUAL_USER" ]; then
        ACTUAL_USER=$(stat -f '%Su' /dev/console 2>/dev/null || echo "")
    fi
    
    if [ -n "$ACTUAL_USER" ] && [ "$ACTUAL_USER" != "root" ]; then
        USER_HOME=$(eval echo "~$ACTUAL_USER")
        USER_MANIFEST="$USER_HOME/Library/Application Support/Mozilla/NativeMessagingHosts/${MANIFEST_NAME}.json"
        
        if [ -f "$USER_MANIFEST" ]; then
            echo "  Found user-level manifest, updating..."
            echo "Found user manifest at: $USER_MANIFEST" >> "$LOG_FILE"
            
            # Update it to point to the installed bridge (not remove, to preserve user's choice)
            cat > "$USER_MANIFEST" << EOF
{
  "name": "$MANIFEST_NAME",
  "description": "Harbor Bridge - AI Agent Platform with MCP Tools",
  "path": "$LAUNCHER_PATH",
  "type": "stdio",
  "allowed_extensions": ["$EXTENSION_ID"]
}
EOF
            # Fix ownership since we're running as root
            chown "$ACTUAL_USER" "$USER_MANIFEST"
            echo "  ✓ User manifest updated: $USER_MANIFEST"
            echo "User manifest updated" >> "$LOG_FILE"
        fi
    fi
}

# =============================================================================
# Install Firefox extension via policy
# =============================================================================
install_firefox_extension() {
    echo "Setting up Firefox extension..."
    
    # Method 1: Try enterprise policies (works on some Firefox installs)
    POLICIES_DIR="/Library/Application Support/Mozilla/policies"
    POLICIES_FILE="$POLICIES_DIR/policies.json"
    
    mkdir -p "$POLICIES_DIR"
    
    # URL-encode the path (spaces -> %20)
    HARBOR_XPI_URL="file://$(echo "$HARBOR_XPI" | sed 's/ /%20/g')"
    
    cat > "$POLICIES_FILE" << EOF
{
  "policies": {
    "Extensions": {
      "Install": [
        "$HARBOR_XPI_URL"
      ]
    },
    "ExtensionSettings": {
      "$EXTENSION_ID": {
        "installation_mode": "normal_installed",
        "install_url": "$HARBOR_XPI_URL"
      }
    }
  }
}
EOF
    echo "  ✓ Firefox policy configured (fallback)"
    
    # Method 2: Open the XPI file to trigger Firefox install prompt
    # Run as the actual user so it opens in their Firefox session
    # Try multiple methods to find the actual user
    ACTUAL_USER="${SUDO_USER:-}"
    if [ -z "$ACTUAL_USER" ]; then
        # Try to get the console user (who is logged in at the GUI)
        ACTUAL_USER=$(stat -f '%Su' /dev/console 2>/dev/null || echo "")
    fi
    if [ -z "$ACTUAL_USER" ]; then
        ACTUAL_USER="$USER"
    fi
    
    echo "  Detected user: $ACTUAL_USER" >> "$LOG_FILE"
    echo "  Detected user: $ACTUAL_USER"
    
    if [ -n "$ACTUAL_USER" ] && [ "$ACTUAL_USER" != "root" ]; then
        echo "  Opening extension in Firefox for user: $ACTUAL_USER"
        echo "  Opening extension in Firefox for user: $ACTUAL_USER" >> "$LOG_FILE"
        
        # Open the XPI file with Firefox - this triggers the install prompt
        # Run in background so it doesn't block the installer
        # Use su to run as the actual user (not root)
        su "$ACTUAL_USER" -c "open -a Firefox '$HARBOR_XPI'" 2>> "$LOG_FILE" &
        
        echo "  ✓ Firefox extension install prompt triggered"
        echo "Extension XPI opened for $ACTUAL_USER" >> "$LOG_FILE"
    else
        echo "  ⚠ Could not determine user (got: '$ACTUAL_USER'), please install extension manually"
        echo "Could not determine user: SUDO_USER='$SUDO_USER' USER='$USER'" >> "$LOG_FILE"
        echo "  Open: $HARBOR_XPI"
    fi
}

# =============================================================================
# Set permissions
# =============================================================================
set_permissions() {
    echo "Setting permissions..."
    
    # Make the bridge executable
    chmod +x "$HARBOR_BIN"
    
    # Make the uninstall script executable
    if [ -f "$HARBOR_DIR/uninstall.sh" ]; then
        chmod +x "$HARBOR_DIR/uninstall.sh"
    fi
    
    echo "Permissions set" >> "$LOG_FILE"
}

# =============================================================================
# Install uninstaller
# =============================================================================
install_uninstaller() {
    echo "Installing uninstaller..."
    
    # Create CLI symlink
    if [ -d "/usr/local/bin" ]; then
        ln -sf "$HARBOR_DIR/uninstall.sh" "/usr/local/bin/harbor-uninstall"
        echo "  ✓ CLI uninstaller: harbor-uninstall"
    fi
    
    # Create uninstaller app from AppleScript
    # The app is built during the pkg creation, we just copy it
    if [ -d "$HARBOR_DIR/Uninstall Harbor.app" ]; then
        cp -R "$HARBOR_DIR/Uninstall Harbor.app" "/Applications/"
        echo "  ✓ Uninstaller app: /Applications/Uninstall Harbor.app"
    fi
    
    echo "Uninstaller installed" >> "$LOG_FILE"
}

# =============================================================================
# Create first-run marker (as the actual user, not root)
# =============================================================================
create_first_run_marker() {
    # Create a marker file so the extension knows this is a fresh install
    # The extension will check for this and show the welcome page
    
    # Get the actual user (the one who ran sudo)
    ACTUAL_USER="${SUDO_USER:-}"
    if [ -z "$ACTUAL_USER" ]; then
        ACTUAL_USER=$(stat -f '%Su' /dev/console 2>/dev/null || echo "")
    fi
    
    if [ -z "$ACTUAL_USER" ] || [ "$ACTUAL_USER" = "root" ]; then
        echo "Could not determine actual user for marker, skipping" >> "$LOG_FILE"
        return 0
    fi
    
    USER_HOME=$(eval echo "~$ACTUAL_USER")
    MARKER_DIR="$USER_HOME/.harbor"
    
    # Create directory as the actual user
    su "$ACTUAL_USER" -c "mkdir -p '$MARKER_DIR'"
    
    # Only create if it doesn't exist (don't overwrite on upgrades)
    if [ ! -f "$MARKER_DIR/.installed" ]; then
        su "$ACTUAL_USER" -c "cat > '$MARKER_DIR/.installed'" << EOF
first_install=$(date +%s)
show_welcome=true
EOF
        echo "First-run marker created for $ACTUAL_USER" >> "$LOG_FILE"
    else
        echo "Upgrade marker exists for $ACTUAL_USER" >> "$LOG_FILE"
    fi
}

# =============================================================================
# Main installation
# =============================================================================

echo ""
echo "═══════════════════════════════════════════════════════════════"
echo "  Harbor - Post-Installation Setup"
echo "═══════════════════════════════════════════════════════════════"
echo ""

# Run installation steps
select_binary
set_permissions
create_launcher
install_native_manifest
install_firefox_extension
install_uninstaller
create_first_run_marker

echo ""
echo "═══════════════════════════════════════════════════════════════"
echo ""
echo "✓ Harbor has been installed successfully!"
echo ""
echo "What happens next:"
echo "  1. Firefox will open with an extension install prompt"
echo "  2. Click 'Add' to install the Harbor extension"
echo "  3. Look for the ⚓ icon in the sidebar"
echo "  4. Start Docker Desktop before using MCP servers"
echo ""
echo "If Firefox doesn't open, manually open this file:"
echo "  $HARBOR_XPI"
echo ""
echo "To uninstall Harbor later:"
echo "  • Double-click 'Uninstall Harbor' in /Applications"
echo "  • Or run: harbor-uninstall"
echo ""
echo "═══════════════════════════════════════════════════════════════"

echo "Post-install completed successfully at $(date)" >> "$LOG_FILE"
exit 0
